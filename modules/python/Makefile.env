PY_PIPENV := $(shell which pipenv 2>/dev/null)
ifneq ($(PY_PIPENV),)
	# Unless WORKON_HOME is set, assume we're going to create ".venv" next to the Pipfile.
	ifeq ($(WORKON_HOME),)
		PIPENV := PIPENV_VENV_IN_PROJECT=1 $(PY_PIPENV)
	else
		PIPENV := PIPENV_VENV_IN_PROJECT= WORKON_HOME='$(WORKON_HOME)' $(PY_PIPENV)
	endif
	PIPENV_RUN := $(PIPENV) run
	# Backwards compatible alias.
	WITH_PIPENV := $(PIPENV_RUN)

	# Get the directory where the Pipfile is.
	PIPENV_PIPFILE_DIR := $(shell $(PIPENV) --where 2> /dev/null)

	ifneq ($(PIPENV_PIPFILE_DIR),)
		ifeq ($(WORKON_HOME),)
			# Again, assume we're going to create ".venv" next to the Pipfile.
			PY_VENV := $(PIPENV_PIPFILE_DIR)/.venv
		else
			# If the venv doesn't exist yet, then this will fail and PY_VENV will be empty
			PY_VENV := $(shell $(PIPENV) --venv 2> /dev/null)
			ifneq ($(.SHELLSTATUS),0)
				# Create the venv, then check for it's location again.
				_ := $(shell $(PIPENV_RUN) install --dev --deploy)
				PY_VENV := $(shell $(PIPENV) --venv 2> /dev/null)
			endif
		endif
	endif
endif

$(PIPENV_PIPFILE_DIR)/Pipfile.lock: $(PIPENV_PIPFILE_DIR)/Pipfile
	$(call assert-set,PIPENV_PIPFILE_DIR)
	@$(MAKE) pipenv/lock

$(PY_VENV)/bin/activate: $(PIPENV_PIPFILE_DIR)/Pipfile.lock
	$(call assert-set,PIPENV_PIPFILE_DIR)
	$(call assert-set,PY_PIPENV)
	$(PIPENV) install --dev --deploy
	touch $(PY_VENV)/bin/activate

$(PY_VENV): $(PY_VENV)/bin/activate

.PHONY: pipenv/check
pipenv/check: python/check
	$(call assert-set,PY_PIPENV)
	echo "Found pipenv: $(PY_PIPENV)"

.PHONY: pipenv/debug
pipenv/debug: python/debug
	$(call print-var,PY_PIPENV)
	$(call print-var,WORKON_HOME)
	$(call print-var,PIPENV)
	$(call print-var,PIPENV_PIPFILE_DIR)
	$(call print-var,PY_VENV)
	$(call print-var,PIPENV_RUN)

## Install and activate a virtual environment using pipenv
pipenv: pipenv/check $(PY_VENV) $(PIPENV_PIPFILE_DIR)/Pipfile.lock
.PHONY: pipenv

# XXX: This is way to generic a target name.
env: pipenv
.PHONY: env

## Lock dependencies
pipenv/lock:
	$(call assert-set,PIPENV_PIPFILE_DIR)
	$(PIPENV) lock
.PHONY: pipenv/lock

## Remove development virtualenv
pipenv/clean:
	$(call assert-set,PIPENV_PIPFILE_DIR)
	$(PIPENV) --rm || true
.PHONY: pipenv/clean

.PHONY: pipenv/generate_requirements
## Generate requirements files based on a Pipfile
pipenv/generate_requirements: $(PIPENV_PIPFILE_DIR)/requirements.txt $(PIPENV_PIPFILE_DIR)/requirements-dev.txt

$(PIPENV_PIPFILE_DIR)/requirements.txt: $(PIPENV_PIPFILE_DIR)/Pipfile
	$(call assert-set,PIPENV_PIPFILE_DIR)
	@echo "Writing requirements from Pipfile to requirements.txt"
	@$(PIPENV_RUN) python -c 'from pipenv.project import Project; section = "packages"; reqs = {package: (ver["version"] if isinstance(ver, dict) else ver) for package, ver in Project().parsed_pipfile[section].items()}; fd = open("requirements.txt", mode="w"); fd.writelines((r if reqs[r] == "*" else "{} {}".format(r, reqs[r])) + "\n" for r in reqs.keys()); fd.close()'

$(PIPENV_PIPFILE_DIR)/requirements-dev.txt: $(PIPENV_PIPFILE_DIR)/Pipfile
	$(call assert-set,PIPENV_PIPFILE_DIR)
	@echo "Writing dev requirements from Pipfile to requirements-dev.txt"
	@$(PIPENV_RUN) python -c 'from pipenv.project import Project; section = "dev-packages"; reqs = {package: (ver["version"] if isinstance(ver, dict) else ver) for package, ver in Project().parsed_pipfile[section].items()}; fd = open("requirements-dev.txt", mode="w"); fd.writelines((r if reqs[r] == "*" else "{} {}".format(r, reqs[r])) + "\n" for r in reqs.keys()); fd.close()'

# The requirements*.txt files will be next to the Pipfile.
# If setup.py and Pipfile are in separate directories, create symlinks.
requirements.txt: $(PIPENV_PIPFILE_DIR)/requirements.txt
	$(call assert-set,PIPENV_PIPFILE_DIR)
	@test -f requirements.txt || ln -sf $(PIPENV_PIPFILE_DIR)/requirements.txt requirements.txt
requirements-dev.txt: $(PIPENV_PIPFILE_DIR)/requirements-dev.txt
	$(call assert-set,PIPENV_PIPFILE_DIR)
	@test -f requirements-dev.txt || ln -sf $(PIPENV_PIPFILE_DIR)/requirements-dev.txt requirements-dev.txt
